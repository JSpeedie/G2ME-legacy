/* General Includes */
#include <dirent.h>
#include <getopt.h>
#include <libgen.h>
#include <math.h>
#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>
/* Windows Includes */
#ifdef _WIN32
#include <windows.h>
/* Non-Windows Includes */
#else
#include <sys/wait.h>
#include <sys/mman.h>
#endif
/* Local Includes */
#include "G2ME.h"
#include "entry.h"
#include "p_files.h"
#include "pr.h"
#include "opp_files.h"
#include "tournament_files.h"
#include "fileops.h"
#include "glicko2.h"
#include "player_dir.h"
#include "data_dir.h"
#include "printing.h"
#include "sorting.h"


char COMMENT_SYMBOL[] = { "#" };


const char ERROR_PLAYER_DIR_DNE[] = { "Error: 'player_dir' either could "
	"not be created or does not exist\n"};


char flag_output_to_stdout = 0;
char silent = 0;
char silent_all = 0;
char verbose = 0;
char use_games = 0;
char keep_players = 0;
int pr_minimum_events = 0;
char colour_output = 1;
char print_ties = 1;
char player_list_file[MAX_FILE_PATH_LEN + 1];
char calc_absent_players = 1;
double flag_outcome_weight = 1;
struct tournament_attendee *tourn_atten;
unsigned long tourn_atten_len = 0;
unsigned long tourn_atten_size = SIZE_TOURNAMENT_NAMES_LEN;
char filter_file_path[MAX_FILE_PATH_LEN + 1];
char f_flag_used = 0;
char player_dir[MAX_FILE_PATH_LEN + 1];
char data_dir[MAX_FILE_PATH_LEN + 1];
struct linked_list_node *tourn_atten_hashtable[SIZE_ATTEN_HASHTABLE];

int get_record(char *, char *, struct record *);
struct record *get_all_records(char *, long *);


/* MurmurHash2, by Austin Appleby, simplified for my usage */
unsigned int simple_murmur_hash2(const void *key) {
	/* Get the length here rather than receiving it as argument (wasting memory
	 * and time on passing a variable) */
	int len = strlen(key);
	/* Set seed to 0 for consistency, which is /demanded/ in my usage */
	int seed = 0;
	/* 'm' and 'r' are mixing constants generated offline.
	 * They're not really 'magic', they just happen to work well. */
	const unsigned int m = 0x5bd1e995;
	const int r = 24;

	/* Initialize the hash to a 'random' value */
	unsigned int h = seed ^ len;

	/* Mix 4 bytes at a time into the hash */
	const unsigned char * data = (const unsigned char *)key;

	while(len >= 4) {
		unsigned int k = *(unsigned int *)data;

		k *= m;
		k ^= k >> r;
		k *= m;

		h *= m;
		h ^= k;

		data += 4;
		len -= 4;
	}
	/* Handle the last few bytes of the input array */
	switch(len) {
		case 3: h ^= data[2] << 16;
		case 2: h ^= data[1] << 8;
		case 1: h ^= data[0];
		        h *= m;
	};

	/* Do a few final mixes of the hash to ensure the last few
	 * bytes are well-incorporated. */
	h ^= h >> 13;
	h *= m;
	h ^= h >> 15;

	return h;
}


/** Clears or empties the hashtable by emptying all buckets (i.e. by setting
 * each array entry in the table to NULL), thereby removing any linked list
 * (and therefore all content) from the table.
 *
 * \return 0.
 */
int hashtable_reset() {
	/* Reset the hash table */
	for (int i = 0; i < SIZE_ATTEN_HASHTABLE; i++) {
		tourn_atten_hashtable[i] = NULL;
	}
	return 0;
}


/** Takes a string that represents the name of a player, a hash of their name
 * (calculated through running simple_murmur_hash2() on their name) and
 * creates an "empty" entry for them in the hashtable with no player data.
 *
 * \param '*s' a string representing the name of the player to be searched for.
 * \param 'hash_of_s' a MurmurHash2 of '*s'. This can be generated by running
 *     simple_murmur_hash2() on '*s'.
 * \return 0.
 */
int hashtable_insert(char *s, unsigned int hash_of_s) {
	/* Make the new node */
	struct linked_list_node *new = malloc(sizeof(struct linked_list_node));
	strncpy(&new->E.name[0], s, MAX_NAME_LEN);
	new->E.len_name = 0;
	new->next = NULL;

	/* If this bucket is empty */
	if (tourn_atten_hashtable[hash_of_s % SIZE_ATTEN_HASHTABLE] == NULL) {
		tourn_atten_hashtable[hash_of_s % SIZE_ATTEN_HASHTABLE] = new;
		return 0;
	}

	struct linked_list_node *current_node = \
		tourn_atten_hashtable[hash_of_s % SIZE_ATTEN_HASHTABLE];

	while (current_node->next != NULL) {
		current_node = current_node->next;
	}
	current_node->next = new;
	return 0;
}


/** Takes a string that represents the name of a player, a hash of their name
 * (calculated through running simple_murmur_hash2() on their name) and
 * modifies the struct entry associated with the player to the one provided.
 *
 * \param '*s' a string representing the name of the player to be searched for.
 * \param 'hash_of_s' a MurmurHash2 of '*s'. This can be generated by running
 *     simple_murmur_hash2() on '*s'.
 * \param '*e' a pointer to a struct entry which will replace the struct entry
 *     currently associated with the player in the hashtable.
 * \return 0 upon success, a negative integer upon failure.
 */
int hashtable_update(char *s, unsigned int hash_of_s, struct entry *e) {
	struct linked_list_node *current_node = \
		tourn_atten_hashtable[hash_of_s % SIZE_ATTEN_HASHTABLE];

	while (current_node != NULL) {
		/* If the name was found, update its info */
		if (0 == strncmp(current_node->E.name, s, MAX_NAME_LEN)) {
			current_node->E = (*e);
			return 0;
		}
		current_node = current_node->next;
	}
	/* If the name could not be found */
	return -1;
}


/** Takes a string that represents the name of a player, a hash of their name
 * (calculated through running simple_murmur_hash2() on their name) and
 * modifies the struct entry *ret to contain a pointer to a struct entry that
 * represents the player's most recent Glicko2 outcome.
 *
 * \param '*s' a string representing the name of the player to be searched for.
 * \param 'hash_of_s' a MurmurHash2 of '*s'. This can be generated by running
 *     simple_murmur_hash2() on '*s'.
 * \param '**ret' a pointer to a pointer of a struct entry which the function
 *     will modify, serving as the return value.
 * \return 0 upon success, a negative integer upon failure. '**ret' is only
 *     changed if the player was found in the hashtable (i.e., when the
 *     function returns 0)
 */
int hashtable_find(char *s, unsigned int hash_of_s, struct entry **ret) {

	struct linked_list_node *current_node = \
		tourn_atten_hashtable[hash_of_s % SIZE_ATTEN_HASHTABLE];

	while (current_node != NULL) {
		/* If the name was found... */
		if (0 == strncmp(current_node->E.name, s, MAX_NAME_LEN)) {
			/* ... return info on it */
			(*ret) = &current_node->E;
			return 0;
		}
		current_node = current_node->next;
	}
	/* If the name could not be found */
	return -1;
}


/** Takes a string that represents the name of a player, a hash of their name
 * (calculated through running simple_murmur_hash2() on their name) and
 * returns 0 if the player is in the hashtable and -1 if they are not.
 *
 * \param '*s' a string representing the name of the player to be searched for.
 * \param 'hash_of_s' a MurmurHash2 of '*s'. This can be generated by running
 *     simple_murmur_hash2() on '*s'.
 * \return 0 if the player exists in the hashtable, and -1 if they could not
 *     be found in the hashtable.
 */
int hashtable_quickfind(char *s, unsigned int hash_of_s) {

	struct linked_list_node *current_node = \
		tourn_atten_hashtable[hash_of_s % SIZE_ATTEN_HASHTABLE];

	while (current_node != NULL) {
		/* If the name was found */
		if (0 == strncmp(current_node->E.name, s, MAX_NAME_LEN)) {
			return 0;
		}
		current_node = current_node->next;
	}
	/* If the name could not be found */
	return -1;
}


/** Takes a pointer to a struct record and initializes it, zeroing the
 * wins, losses and ties, and mallocing for the last outcome string.
 *
 * \param '*r' a pointer to a struct record that this function will initialize.
 * \return 0 upon success, a negative integer upon failure.
 */
int init_record(struct record *r) {
	r->wins = 0;
	r->losses = 0;
	r->ties = 0;
	r->num_outcomes = MAX_OUTCOME_STRING_LEN;
	r->last_outcomes = \
		(char *)malloc(sizeof(char) * r->num_outcomes);

	if (r->last_outcomes == NULL) {
		return -1;
	} else {
		return 0;
	}
}


/** Updates a struct player's glicko data (and corresponding file) assuming
 * the player went through a given set on a given date. If the player does
 * not have a corresponding file, one is created and initialized to the
 * default glicko2 values.
 *
 * \param '*p1_name' string representing player-1's name
 * \param '*p2_name' string representing player-2's name
 * \param 'p2_id' a short representing player-2's id
 * \param '*p1' a struct player representing player-1
 * \param '*p2' a struct player representing player-2
 * \param '*p1_gc' a double representing the number of games player-1 won in
 *     the set
 * \param '*p2_gc' a double representing the number of games player-2 won in
 *     the set
 * \param 'day' a char representing the day of the month the set was played on
 * \param 'month' a char representing the month the set was played in
 * \param 'year' a short representing the year the set was played in
 * \param 't_id' a short representing the tournament id of the tournament
 *     this outcome took place at.
 * \param 't_name' a string containing the name of the tournament this outcome
 *     took place at.
 * \return void
 */
void update_player_on_outcome(short p1_id, char* p1_name, short p2_id, \
	char* p2_name, struct player* p1, struct player* p2, char* p1_gc, \
	char* p2_gc, char day, char month, short year, short t_id, \
	char* t_name, short season_id) {

	char *full_p1_path = player_dir_file_path_with_player_dir(player_dir, p1_name);
	char *full_p2_path = player_dir_file_path_with_player_dir(player_dir, p2_name);

	unsigned int p1_name_hash = simple_murmur_hash2(p1_name);
	unsigned int p2_name_hash = simple_murmur_hash2(p2_name);

	char p1_in_mem;
	struct entry *p1_E = NULL;
	struct entry p1_latest;
	p1_in_mem = hashtable_find(p1_name, p1_name_hash, &p1_E);
	/* If player found in mem, but data is no up to date, don't use data */
	// TODO: less hacky way of checking if player is actually in mem
	// TODO: change to GlickoData to avoid hacky-ness
	if (p1_in_mem == 0 || p1_E != NULL) {
		if (p1_E->len_name == 0) p1_in_mem = -1;
	}
	if (p1_in_mem == 0) {
		init_player_from_entry(p1, p1_E);
		/* If this outcome was not a part of a season, write the season
		* as the same as the latest season the player was in */
		if (season_id == -1) {
			season_id = p1_E->season_id;
		}
	/* If the player data could not be found in memory (the hash table) */
	} else {
		/* If the file does not exist, init the player struct to defaults */
#ifdef __linux__
		if (access(full_p1_path, R_OK | W_OK) == -1) {
#elif _WIN32
		if (access(full_p1_path, 0) == -1) {
#else
		if (access(full_p1_path, R_OK | W_OK) == -1) {
#endif
			setRating(p1, DEF_RATING);
			setRd(p1, DEF_RD);
			p1->vol = DEF_VOL;
		/* File does not yet exist */
		} else {
			/* Read latest entries into usable data */
			int ret;
			if (0 == (ret = p_file_read_last_entry_minimal(full_p1_path, \
				&p1_latest))) {

				p1_latest.id = p1_id;

				/* Update player in memory to avoid reading this file again */
				if (p1_E != NULL) {
					// TODO: change to GlickoData struct to save on copying?
					(*p1_E) = p1_latest;
				/* If the player data is not already in memory,
				 * do more work intensive method */
				} else {
					hashtable_update(p1_name, p1_name_hash, &p1_latest);
				}

				init_player_from_entry(p1, &p1_latest);
				/* If this outcome was not a part of a season, write the season
				* as the same as the latest season the player was in */
				if (season_id == -1) {
					season_id = p1_latest.season_id;
				}
			} else {
				fprintf(stderr, \
					"p_file_read_last_entry (%d) (update_player_on_outcome)", \
					ret);
				perror("");
			}
		}
	}

	char p2_in_mem;
	struct entry *p2_E = NULL;
	struct entry p2_latest;
	p2_in_mem = hashtable_find(p2_name, p2_name_hash, &p2_E);
	/* If player found in mem, but data is no up to date, don't use data */
	// TODO: less hacky way of checking if player is actually in mem
	if (p2_in_mem == 0 || p2_E != NULL) {
		if (p2_E->len_name == 0) p2_in_mem = -1;
	}
	if (p2_in_mem == 0) {
		init_player_from_entry(p2, p2_E);
		/* If this outcome was not a part of a season, write the season
		* as the same as the latest season the player was in */
		if (season_id == -1) {
			season_id = p2_E->season_id;
		}
	/* If the player data could not be found in memory (the hash table) */
	} else {
		/* If the file does not exist, init the player struct to defaults */
#ifdef __linux__
		if (access(full_p2_path, R_OK | W_OK) == -1) {
#elif _WIN32
		if (access(full_p2_path, 0) == -1) {
#else
		if (access(full_p2_path, R_OK | W_OK) == -1) {
#endif
			setRating(p2, DEF_RATING);
			setRd(p2, DEF_RD);
			p2->vol = DEF_VOL;
		} else {
			/* Read latest entries into usable data */
			int ret;
			if (0 == (ret = p_file_read_last_entry_minimal(full_p2_path, \
				&p2_latest))) {

				p2_latest.id = p2_id;
				// TODO: remove
				// print_entry_verbose(p2_latest);

				/* Update player in memory to avoid reading this file again */
				if (p2_E != NULL) {
					// TODO: change to GlickoData struct to save on copying?
					(*p2_E) = p2_latest;
				/* If the player data is not already in memory,
				 * do more work intensive method */
				} else {
					hashtable_update(p2_name, p2_name_hash, &p2_latest);
				}

				init_player_from_entry(p2, &p2_latest);
			} else {
				fprintf(stderr, \
					"p_file_read_last_entry (%d) (update_player_on_outcome)", \
					ret);
				perror("");
			}
		}
	}

	p1->_tau = DEF_TAU;
	p2->_tau = DEF_TAU;

	struct player new_p1 = *p1;
	struct player new_p2 = *p2;
	double p1_result = (double) (*(p1_gc) > *(p2_gc));
	double p2_result = (double) (*(p1_gc) < *(p2_gc));

	update_player(&new_p1, &p2->__rating, 1, &p2->__rd, &p1_result);
	update_player(&new_p2, &p1->__rating, 1, &p1->__rd, &p2_result);

	/* Adjust changes in glicko data based on weight of given game/set */
	new_p1.__rating = \
		p1->__rating + ((new_p1.__rating - p1->__rating) * flag_outcome_weight);
	new_p1.__rd = p1->__rd + ((new_p1.__rd - p1->__rd) * flag_outcome_weight);
	new_p1.vol = p1->vol + ((new_p1.vol - p1->vol) * flag_outcome_weight);

	struct entry p1_new_entry =
		create_entry(&new_p1, p1_name, p2_name, *p1_gc, *p2_gc, \
			day, month, year, t_name, season_id, 1);

	p1_new_entry.opp_id = p2_id;
	p1_new_entry.tournament_id = t_id;
	int ret = p_file_append_entry_to_file_id(&p1_new_entry, full_p1_path);

	p1_new_entry.id = p1_id;

	/* Update player data in memory */
	if (p1_E != NULL) {
		// TODO: change to GlickoData struct to save on copying?
		(*p1_E) = p1_new_entry;
	/* If the player data is not already in memory,
	 * do more work intensive method */
	} else {
		hashtable_update(p1_name, p1_name_hash, &p1_new_entry);
	}

	if (ret != 0) {
		fprintf(stderr, "Error appending entry to file \"%s\"\n", \
			full_p1_path);
		fprintf(stderr, "ret = \"%d\"\n", ret);
	}

	free(full_p1_path);
	free(full_p2_path);

	return;
}


/* Takes a player file, some date info and an event name, and adjusts
 * the given player's RD in their file provided it does not conflict
 * with the date rule of no more than 1 adjustment in a day.
 *
 * \param '*player_file' a file path to a player entry-file
 *     which will have their RD adjusted.
 * \param 'day' the day of the RD adjustment
 * \param 'month' the month of the RD adjustment
 * \param 'year' the year of the RD adjustment
 * \param '*t_id' the id of the event that they were absent from.
 * \param '*t_name' the name of the event that they were absent from.
 */
void adjust_absent_player(char *player_file, char day, char month, \
	short year, short t_id, char *t_name) {

	char* full_file_path = \
		player_dir_file_path_with_player_dir(player_dir, player_file);

	/* If the player who did not compete has a player file */
#ifdef __linux__
	if (access(full_file_path, R_OK | W_OK) != -1) {
#elif _WIN32
	//if (_access(full_file_path) != -1) {
	if (access(full_file_path, R_OK | W_OK) != -1) {
#else
	if (access(full_file_path, R_OK | W_OK) != -1) {
#endif
		struct player P;
		struct entry latest_ent;
		if (0 == p_file_read_last_entry_absent(data_dir, full_file_path, \
			&latest_ent)) {

			/* If this adjustment is taking place on a different
			 * day from their last entry */
			if (latest_ent.day != day || latest_ent.month != month \
				|| latest_ent.year != year) {

				init_player_from_entry(&P, &latest_ent);
				did_not_compete(&P);
				/* Only need to change entry RD since that's all
				 * Step 6 changes */
				latest_ent.RD = getRd(&P);
				/* Change qualities of the entry to reflect
				 * that it was not a real set, but a
				 * did_not_compete. opp_id of 0 is the opp_id of "-" */
				latest_ent.opp_id = 0;
				latest_ent.len_opp_name = strlen(latest_ent.opp_name);
				latest_ent.gc = 0;
				latest_ent.opp_gc = 0;
				latest_ent.day = day;
				/* Modify first bit of 'day' to tell whether this was a real
				 * set/game. Day should always be <= 31 leaving 3 extra bits.
				 * Bitwise OR with b10000000 */
				latest_ent.day = \
					latest_ent.day | (1 << ((sizeof(latest_ent.day) * 8) - 1));
				latest_ent.month = month;
				latest_ent.year = year;
				latest_ent.tournament_id = t_id;
				strncpy(latest_ent.t_name, t_name, MAX_NAME_LEN);
				latest_ent.len_t_name = strlen(latest_ent.t_name);
				latest_ent.t_name[latest_ent.len_t_name] = '\0';
				p_file_append_adjustment_to_file_id(&latest_ent, \
					full_file_path);
			}
		}
	}
	free(full_file_path);
	/* If they do not then they have never competed, so skip them */
	return;
}


/* Define a struct for passing arguments to the thread */
typedef struct thread_args {
	unsigned long num_adjustments;
	char *files;
	unsigned long size_of_files;
	char day;
	char month;
	short year;
	unsigned short t_id;
	char **t_name;
}ThreadArgs;


/** Helper function for RD-adjusting a list of players on a specified date. */
void *adjust_p(void *arg) {
	struct thread_args *t = (struct thread_args *) arg;
	/* Get this processes' list of player names that did not compete and
	 * apply step 6 to them and append to player file */
	for (unsigned long j = 0; j < t->num_adjustments; j++) {
		adjust_absent_player(&(t->files[j * (MAX_NAME_LEN + 1)]), \
			t->day, t->month, t->year, t->t_id, *(t->t_name));
	}
	return NULL;
}


/** All players whose last entry is not for the event of 't_name'
 * get their Glicko2 data adjusted. Unless their last RD adjustment
 * was within the same day.
 *
 * \param 'day' a char representing the day of the tournament
 * \param 'month' a char representing the month of the tournament
 * \param 'year' a char representing the year of the tournament
 * \param '*t_id' a short representing the id of the tournament.
 * \param '*t_name' a string containing the name of the tournament.
 * \param 'available_cores' the number of available cores or processors
 *     on the computer. Used to determine how many threads to divide
 *     the work up between.
 * \return void.
*/
void adjust_absent_players_no_file(char day, char month, \
	short year, short t_id, char* t_name, int available_cores) {

	DIR *p_dir;
	/* If the directory could not be accessed, print error and return */
	if ((p_dir = opendir(player_dir)) == NULL) {
		perror("opendir (adjust_absent_players_no_file)");
		closedir(p_dir);
		return;
	}

	char did_not_comp = 1;

	ThreadArgs args[available_cores];
	/* Initialize parent thread work */
	args[0].size_of_files = 2 * MINIMUM_ADJ_BEFORE_FORK;
	args[0].files = \
		(char *)malloc(args[0].size_of_files * (MAX_NAME_LEN + 1));

	/* Set static data for all threads such as date, tournament id, etc */
	for (int i = 0; i < available_cores; i++) {
		args[i].num_adjustments = 0;
		args[i].day = day;
		args[i].month = month;
		args[i].year = year;
		args[i].t_id = t_id;
		args[i].t_name = &t_name;
	}

	int cur_f = 0;
	int total_threads_needed = 0;
	char all_thread_min_cap_reached = 0;

	short num_players;
	char *players = \
		opp_file_get_all_opponent_names(data_dir, EXCLUDE_RD_ADJ, &num_players);

	/* Create a list of player files, set work for threads */
	for (int y = 0; y < num_players; y++) {
		/* Reset variable to assume player did not compete */
		did_not_comp = 1;

		/* Binary search on file to find given name's id */
		long L = 0;
		long R = tourn_atten_len - 1;
		long m;
		while (L <= R) {
			m = floor(((double) (L + R)) / 2.0);
			/* Compare array[m] with the name being searched for */
			int comp = strncmp(&tourn_atten[m].name[0], \
				&players[(MAX_NAME_LEN + 1) * y], MAX_NAME_LEN);

			if (0 > comp) {
				L = m + 1;
			} else if (0 < comp) {
				R = m - 1;
			} else {
				did_not_comp = 0;
				R = L - 1; /* Terminate loop */
			}
		}

		if (did_not_comp) {
			long next_name = \
				(args[cur_f].num_adjustments) * (MAX_NAME_LEN + 1);
			/* realloc if necessary */
			if (args[cur_f].num_adjustments + 1 > args[cur_f].size_of_files) {
				args[cur_f].size_of_files *= 2;
				args[cur_f].files = (char *) realloc(args[cur_f].files, \
					(MAX_NAME_LEN + 1) * args[cur_f].size_of_files);
				if (args[cur_f].files == NULL) {
					perror("realloc (adjust_absent_players_no_file)");
					return;
				}
			}

			/* Copy file name into proper thread input file list */
			strncpy(&args[cur_f].files[next_name], \
				&players[(MAX_NAME_LEN + 1) * y], \
				MAX_NAME_LEN + 1);
			args[cur_f].num_adjustments++;

			if (all_thread_min_cap_reached == 0) {
				/* If this thread has hit its minimum capacity */
				if (args[cur_f].num_adjustments >= MINIMUM_ADJ_BEFORE_FORK) {
					cur_f++;
					if (cur_f >= available_cores) {
						all_thread_min_cap_reached = 1;
					} else {
						args[cur_f].size_of_files = MINIMUM_ADJ_BEFORE_FORK;
						size_t new_size = args[cur_f].size_of_files \
							* (MAX_NAME_LEN + 1);
						args[cur_f].files = (char *)malloc(new_size);
						args[cur_f].num_adjustments = 0;
						total_threads_needed++;
					}

				}
			/* Otherwise, distribute RD adjustments evenly amongst threads */
			} else {
				cur_f++;
				if (cur_f >= available_cores) {
					cur_f = 0;
				}
			}
		}
	}

	closedir(p_dir);

	pthread_t thread_id[available_cores - 1];

	for (int f = 0; f < total_threads_needed; f++) {
		pthread_create(&thread_id[f], NULL, adjust_p, &args[f+1]);
	}

	/* Have parent thread do its work */
	adjust_p(&args[0]);

	/* Wait for all threads to finish */
	for (int f = 0; f < total_threads_needed; f++) {
		pthread_join(thread_id[f], NULL);
		free(args[f].files);
	}
}


/** Takes a bracket file and updates the ratings of all the players
 * mentioned in the bracket file as well as performing an RD adjustment
 * on players who were absent.
 *
 * \param '*bracket_file_path' the file path of a bracket file which, on
 *     each line has the format of "[p1_name] [p2_name] [p1_game_count]
 *     [p2_game_count] [day] [month] [year]"
 * \return 0 upon sucess, < 0 upon failure.
 */
// TODO: break up function.
// TODO: make sscanfs safe/secure.
//       Right now they risk a stack/buffer overflow
int update_players(char* bracket_file_path, short season_id) {
	// TODO: put somewhere else. Would be useful to not reset, possibly
	hashtable_reset();
	/* Set to 0 since the bracket is beginning and no names are stored */
	tourn_atten_len = 0;
	size_t array_size = \
		(sizeof(struct tournament_attendee)) * tourn_atten_size;
	tourn_atten = \
		(struct tournament_attendee *)malloc(array_size);

	FILE *bracket_file = fopen(bracket_file_path, "r");
	if (bracket_file == NULL) {
		fprintf(stderr, "Error opening file \"%s\" (update_players): ", \
			bracket_file_path);
		perror("");
		return -1;
	}

	char line[MAX_FILE_PATH_LEN];
	char p1_name[MAX_NAME_LEN];
	char p2_name[MAX_NAME_LEN];
	char p1_gc;
	char p2_gc;
	char day;
	char month;
	short year;
	char t_name[MAX_NAME_LEN];
	memset(t_name, 0, sizeof(t_name));
	strncpy(t_name, basename(bracket_file_path), sizeof(t_name));

	struct entry Et;
	strncpy(Et.t_name, t_name, sizeof(t_name));
	Et.len_t_name = strlen(Et.t_name);
	int ret = 0;
	/* If the tournament file does not already contain an id for this
	 * tournament */
	if (-1 == (ret = t_file_contains_tournament(data_dir, Et.t_name))) {
		/* Add the new tournament to the tournament file. This also corrects
		 * the t_id if it is incorrect */
		if (0 != t_file_add_new_tournament(data_dir, &Et)) return -8;
	/* If there was an error */
	} else if (ret < -1) {
		return -9;
	/* If the tournament file does contain an id for this tournament */
	} else {
		/* Fix the tournament_id in case it wasn't set */
		Et.tournament_id = (unsigned short) ret;
	}

	int outcomes_size = SIZE_OUTCOMES;
	char *outcomes = \
		(char *)malloc((MAX_BRACKET_FILE_LINE_LEN + 1) * outcomes_size);

	int num_outcomes = 0;
	while (fgets(line, sizeof(line), bracket_file)) {
		/* Remove comments from text */
		char parse_line = 0;
		unsigned long i = 0;
		unsigned long comment_symbol_len = strlen(COMMENT_SYMBOL);

		if (comment_symbol_len > 0) {
			while (i <= strlen(line) - comment_symbol_len) {
				/* If it reaches a character that matches the first character
				 * of the comment symbol */
				if (line[i] == COMMENT_SYMBOL[0]) {
					/* If there is a comment, do not parse the line */
					if (strncmp( \
						&line[i], COMMENT_SYMBOL, comment_symbol_len) == 0) {

						line[i] = '\0';
						break;
					}
				}
				i++;
			}
			i = 0;
		}

		/* Check if the line is non-empty */
		while (i < strlen(line)) {
			/* If it reaches a non-whitespace character */
			if (line[i] != '	' && line[i] != ' ' \
				&& line[i] != '\n' && line[i] != '\r') {

				parse_line = 1;
				break;
			}
			i++;
		}
		if (parse_line == 1) {
			/* If there is no space to add this bracket path, reallocate */
			if (num_outcomes + 1 > outcomes_size) {
				outcomes_size += REALLOC_OUTCOMES_INC;
				outcomes = (char *) realloc(outcomes, \
					(MAX_FILE_PATH_LEN + 1) * outcomes_size);
				if (outcomes == NULL) {
					perror("realloc (update_players)");
					return -2;
				}
			}
			strncpy( \
				&outcomes[num_outcomes * (MAX_BRACKET_FILE_LINE_LEN + 1)], \
				&line[0], MAX_BRACKET_FILE_LINE_LEN);
			num_outcomes++;
		}
	}

	fclose(bracket_file);

	/* Generate tournament attendee names list so RD-adjustments can
	 * take place during Glicko2 number crunching */
	for (int j = 0; j < num_outcomes; j++) {
/* Read data from one line of bracket file into all the variables */
#ifdef _WIN32
		/* char *token = \ */
		/* 	strtok(&outcomes[j * (MAX_FILE_PATH_LEN + 1)], " "); */
		/* int temp; */

		/* if (token == NULL) fprintf(stderr, \ */
		/* 	"Not enough arguments given in bracket file\n"); */
		/* strncpy(p1_name, token, MAX_NAME_LEN); */

		/* token = strtok(NULL, " "); */
		/* if (token == NULL) fprintf(stderr, \ */
		/* 	"Not enough arguments given in bracket file\n"); */
		/* strncpy(p2_name, token, MAX_NAME_LEN); */

		/* token = strtok(NULL, " "); */
		/* if (token == NULL) fprintf(stderr, \ */
		/* 	"Not enough arguments given in bracket file\n"); */
		/* sscanf(token, "%d", &temp); */
		/* p1_gc = (char)temp; */

		/* token = strtok(NULL, " "); */
		/* if (token == NULL) fprintf(stderr, \ */
		/* 	"Not enough arguments given in bracket file\n"); */
		/* sscanf(token, "%d", &temp); */
		/* p2_gc = (char)temp; */

		/* token = strtok(NULL, " "); */
		/* if (token == NULL) fprintf(stderr, \ */
		/* 	"Not enough arguments given in bracket file\n"); */
		/* sscanf(token, "%d", &temp); */
		/* day = (char)temp; */

		/* token = strtok(NULL, " "); */
		/* if (token == NULL) fprintf(stderr, \ */
		/* 	"Not enough arguments given in bracket file\n"); */
		/* sscanf(token, "%d", &temp); */
		/* month = (char)temp; */

		/* token = strtok(NULL, " "); */
		/* if (token == NULL) fprintf(stderr, \ */
		/* 	"Not enough arguments given in bracket file\n"); */
		/* sscanf(token, "%d", &temp); */
		/* year = (short)temp; */



		sscanf(&outcomes[j * (MAX_FILE_PATH_LEN + 1)], \
			"%s %s %hhd %hhd %hhd %hhd %hd", \
			p1_name, p2_name, &p1_gc, &p2_gc, &day, &month, &year);
/* If compiling on macOS or Linux */
#else
		sscanf(&outcomes[j * (MAX_FILE_PATH_LEN + 1)], \
			"%s %s %hhd %hhd %hhd %hhd %hd", \
			p1_name, p2_name, &p1_gc, &p2_gc, &day, &month, &year);
#endif
		unsigned int p1_name_hash = simple_murmur_hash2(p1_name);
		unsigned int p2_name_hash = simple_murmur_hash2(p2_name);
		char already_in = 0;
		char already_in2 = 0;
		if (0 == hashtable_quickfind(p1_name, p1_name_hash)) {
			already_in = 1;
		} else {
			hashtable_insert(p1_name, p1_name_hash);
		}

		if (0 == hashtable_quickfind(p2_name, p2_name_hash)) {
			already_in2 = 1;
		} else {
			hashtable_insert(p2_name, p2_name_hash);
		}

		if (calc_absent_players == 1) {

			//for (unsigned long i = 0; i < tourn_atten_len; i++) {
			//	/* If the name already exists in the list of entrants,
			//	 * don't add */
			//	if (0 == strcmp(p1_name, &tourn_atten[i].name[0])) {
			//		already_in = 1;
			//		/* If both names need to be added, get to work. No need
			//		 * to search further */
			//		if (already_in2 == 1) {
			//			break;
			//		}
			//	}
			//	if (0 == strcmp(p2_name, &tourn_atten[i].name[0])) {
			//		already_in2 = 1;
			//		/* If both names need to be added, get to work. No need
			//		 * to search further */
			//		if (already_in == 1) {
			//			break;
			//		}
			//	}
			//}
			/* If the additions to be made will overflow the tournament
			 * attendee array, realloc it to fit them */
			if (tourn_atten_len + already_in + already_in2 \
				> tourn_atten_size) {

				tourn_atten_size *= REALLOC_TOURNAMENT_NAMES_FACTOR;
				tourn_atten = \
					(struct tournament_attendee *)realloc(tourn_atten, \
					(sizeof(struct tournament_attendee)) * tourn_atten_size);
				if (tourn_atten == NULL) {
					perror("realloc (update_players)");
					return -2;
				}
			}
			if (!already_in) {
				strncpy(&tourn_atten[tourn_atten_len].name[0], \
					p1_name, MAX_NAME_LEN);
				tourn_atten_len++;
			}
			if (!already_in2) {
				strncpy(&tourn_atten[tourn_atten_len].name[0], \
					p2_name, MAX_NAME_LEN);
				tourn_atten_len++;
			}
		}
	}

	char *full_opp_file_path = data_dir_file_path_opp_file(data_dir);

	FILE* opp_file = fopen(full_opp_file_path, "rb+");
	if (opp_file == NULL) {
		fprintf(stderr, "Error opening file \"%s\" (update_players): ", \
			full_opp_file_path);
		perror("");
		return -1;
	}

	/* Id all tournament attendees */
	for (unsigned long o = 0; o < tourn_atten_len; o++) {
		int ret = 0;
		/* Get opp_ids for all players who attended this tournament */
		/* If the opponent file does not already contain an id for this opponent */
		struct entry E;
		if (-1 == (ret = \
			opp_file_open_contains_opponent(opp_file, \
				&tourn_atten[o].name[0]))) {

			/* Add the new opponent to the opponent file. This also corrects
			 * the t_id if it is incorrect */
			strncpy(&E.opp_name[0], &tourn_atten[o].name[0], MAX_NAME_LEN);
			E.len_opp_name = strlen(E.opp_name);
			if (0 != opp_file_add_new_opponent(data_dir, &E)) return -8;
		/* If there was an error */
		} else if (ret < -1) {
			return -9;
		/* If the opponent file does contain an id for this opponent */
		} else {
			/* Fix the opp_id in case it wasn't set */
			E.opp_id = (unsigned short) ret;
		}
		tourn_atten[o].id = E.opp_id;
		// Set id in hashtable too
		struct entry *hashtable_E;
		unsigned int player_hash = \
			simple_murmur_hash2(&tourn_atten[o].name[0]);
		int search = hashtable_find(&tourn_atten[o].name[0], player_hash, \
			&hashtable_E);

		if (0 == search && hashtable_E != NULL) {
			hashtable_E->id = E.opp_id;
		} else {
			fprintf(stderr, "Error: update_players: was unable to update " \
				"player id in hashtable for player \"%s\"\n", \
				&tourn_atten[o].name[0]);
		}
	}

	fclose(opp_file);
	free(full_opp_file_path);

	merge_sort_tournament_attendees(tourn_atten, tourn_atten_len);

	int available_cores;
/* Set the max number of forks to the number of processors available */
#ifdef _WIN32
	SYSTEM_INFO info;
	GetSystemInfo(&info);
	available_cores = info.dwNumberOfProcessors;
#else
	available_cores = sysconf(_SC_NPROCESSORS_ONLN);
#endif
	if (available_cores < 1) available_cores = 1;

#ifdef _WIN32
	if (calc_absent_players == 1) {
		adjust_absent_players_no_file(day, month, year, \
			Et.tournament_id, t_name, available_cores);
	}
#else
	/* Create the necessary synchronization variables. In this case,
	* a fork occurs where the parent runs through all the tournament outcomes,
	* calculating new Glicko2 data for all players who attended while the
	* child process (likely through a collection of pthreads) performs
	* RD adjustments on all players who did not attend. We want the child
	* and parent to wait for one another to finish before moving on to the
	* next bracket and this will be achieved by creating a barrier through
	* the use of 1 semaphore, 2 mutexes, and 3 ints. */

	/* mmap() the semaphore, the two mutexes, and 2 of the 3 synchronization
	 * integers so they can be shared between processes */
	sem_t *update_players_semaphore;
	if (MAP_FAILED == (update_players_semaphore = mmap(NULL, sizeof(sem_t), \
		PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0))) {

		fprintf(stderr, \
			"ERROR: Unable to mmap() semaphore when crunching bracket.\n");
	}
	pthread_mutex_t *proc_at_or_past_barrier_mutex;
	if (MAP_FAILED == (proc_at_or_past_barrier_mutex = mmap(NULL, sizeof(pthread_mutex_t), \
		PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0))) {

		fprintf(stderr, \
			"ERROR: Unable to mmap() mutex when crunching bracket.\n");
	}
	pthread_mutex_t *proc_finished_mutex;
	if (MAP_FAILED == (proc_finished_mutex = mmap(NULL, sizeof(pthread_mutex_t), \
		PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0))) {

		fprintf(stderr, \
			"ERROR: Unable to mmap() mutex when crunching bracket.\n");
	}
	/* A variable to be protected by its own mutex that stores how many threads
	 * have completed their work. It is used to determine which thread is the
	 * last one to finish its work (and thus should increment the semaphore). */
	char *proc_finished = NULL;
	if (MAP_FAILED == (proc_finished = mmap(NULL, sizeof(char), \
		PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0))) {

		fprintf(stderr, \
			"ERROR: Unable to mmap() synchronization variable when crunching bracket.\n");
	}
	*proc_finished = 0;
	/* A variable to be protected by its own mutex that stores how many threads
	 * are at or have past the barrier. It is used to determine which thread is
	 * the last one to pass the barrier (and thus must cleanup the
	 * synchronization objects. */
	char *proc_at_or_past_barrier = NULL;
	if (MAP_FAILED == (proc_at_or_past_barrier = mmap(NULL, sizeof(char), \
		PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0))) {

		fprintf(stderr, \
			"ERROR: Unable to mmap() synchronization variable when crunching bracket.\n");
	}
	*proc_at_or_past_barrier = 0;
	/* A variable that represents how many processes must reach the barrier
	 * before the barrier is lowered for all processes. We initialize it
	 * to 0 here but it will be set properly later. */
	char barrier_count = 0;

	/* In order to ensure synchronization, the involved processes
	 * will perform the following steps:
	 *
	 * 1. Complete its respective work.
	 * 2. a. Lock the proc_finished mutex.
	 *    b. Increment the proc_finished variable.
	 *    c. Store in a variable whether proc_finished is now equal to the
	 *       number of processes/threads being synchronized (i.e., the
	 *       barrier count).
	 *    d. Unlock the proc_finished mutex
	 *    e. Check the aforementioned variable to determine if proc_finished
	 *       is equal to the barrier count. If it is, that means that the
	 *       barrier threshold has been met, and all processes waiting at the
	 *       barrier can proceed. If this is the case, increment the semaphore.
	 * 4. a. Lock the proc_at_or_past_barrier mutex.
	 *    b. Increment the proc_at_or_past_barrier variable.
	 *    c. Store in a variable whether proc_at_or_past_barrier is now equal
	 *       to the number of processes/threads being synchronized (i.e., the
	 *       barrier count).
	 *    d. Decrement the semaphore. The semaphore will wait to be decremented
	 *       until the last process has finished its work.
	 *    e. Unlock the proc_at_or_past_barrier mutex (allowing another
	 *       finished process to check if all other processes have finished)
	 *    f. Increment the semaphore (so the next finished process' check will
	 *       work).
	 *    g. Check the aforementioned variable to determine if
	 *       proc_at_or_past_barrier is equal to the barrier count. If it is,
	 *       that means that this process is the last one to get through the
	 *       barrier. Destroy the proc_finished mutex, the
	 *       proc_at_or_past_barrier mutex, and the semaphore.
	 *    h. munmap() the memory segment for the proc_finished mutex,
	 *       the proc_at_or_past_barrier mutex, the semaphore, and the 2
	 *       mmapped synchronization variables.
	 * 5. The process can now go on to do its "post-barrier" work!
	 */

	if (calc_absent_players == 1) {
		if (available_cores > 1) {
			/* Init the semaphore to be shared between processes (pshared is
			 * non-zero) and to have a value of 0 */
			if (-1 == sem_init(update_players_semaphore, 1, 0)) {
				fprintf(stderr, \
					"ERROR: Unable to initialize semaphore when crunching bracket.\n");
			}
			/* Initialize the barrier count to the number of processes that
			 * must have reached the barrier before any of them can proceed. In
			 * this case we will only have a 2 processes, a parent and child */
			barrier_count = 2;
			/* Init the mutex to be shared between processes */
			pthread_mutexattr_t proc_at_or_past_barrier_mutex_attr;
			pthread_mutexattr_init(&proc_at_or_past_barrier_mutex_attr);
			pthread_mutexattr_setpshared(&proc_at_or_past_barrier_mutex_attr, \
				PTHREAD_PROCESS_SHARED);

			if (-1 == pthread_mutex_init(proc_at_or_past_barrier_mutex, \
				&proc_at_or_past_barrier_mutex_attr)) {

				fprintf(stderr, \
					"ERROR: Unable to initialize mutex when crunching bracket.\n");
			}

			pthread_mutexattr_destroy(&proc_at_or_past_barrier_mutex_attr);

			/* Init the mutex to be shared between processes */
			pthread_mutexattr_t proc_finished_mutex_attr;
			pthread_mutexattr_init(&proc_finished_mutex_attr);
			pthread_mutexattr_setpshared(&proc_finished_mutex_attr, \
				PTHREAD_PROCESS_SHARED);

			if (-1 == pthread_mutex_init(proc_finished_mutex, \
				&proc_finished_mutex_attr)) {

				fprintf(stderr, \
					"ERROR: Unable to initialize mutex when crunching bracket.\n");
			}

			pthread_mutexattr_destroy(&proc_finished_mutex_attr);

			pid_t p;
			p = fork();
			/* If child process, run adjustments while parent crunches numbers
			 * in accordance with the barrier protocol specified above */
			if (p == 0) {
				/* 1. Do the child process' work */
				adjust_absent_players_no_file(day, month, year, \
					Et.tournament_id, t_name, available_cores);

				/* 2a. Lock the proc_finished mutex */
				if (0 != pthread_mutex_lock(proc_finished_mutex)) {
					fprintf(stderr, \
						"ERROR: Failed to attempt to lock mutex when crunching bracket.\n");
				}

				/* 2b. Increment the proc_finished variable. */
				(*proc_finished)++;

				/* 2c. Store in a variable whether or not the barrier count has
				 * been reached */
				char is_last_process = ((*proc_finished) == barrier_count);

				/* 2d. Unlock the proc_finished mutex */
				if (0 != pthread_mutex_unlock(proc_finished_mutex)) {
					fprintf(stderr, \
						"ERROR: Failed to attempt to lock mutex when crunching bracket.\n");
				}

				/* 2e. If the barrier count has been reached, increment the
				 * semaphore */
				if (is_last_process == 1) {
					if (-1 == sem_post(update_players_semaphore)) {
						fprintf(stderr, \
							"ERROR: Failed to post semaphore when crunching bracket.\n");
					}
				}

				/* 3a. Wait for the proc_at_or_past_barrier mutex. */
				if (0 != pthread_mutex_lock(proc_at_or_past_barrier_mutex)) {
					fprintf(stderr, \
						"ERROR: Failed to attempt to lock mutex when crunching bracket.\n");
				}

				/* 3b. Increment the proc_at_or_past_barrier variable. */
				(*proc_at_or_past_barrier)++;

				/* 3c. Store in a variable whether or not the barrier count has
				 * been reached */
				is_last_process = ((*proc_at_or_past_barrier) == barrier_count);

				/* 3d. Decrement the semaphore */
				if (-1 == sem_wait(update_players_semaphore)) {
					fprintf(stderr, \
						"ERROR: Failed to wait for semaphore when crunching bracket.\n");
				}

				/* 3e. Unlock the proc_at_or_past_barrier mutex. */
				if (0 != pthread_mutex_unlock(proc_at_or_past_barrier_mutex)) {
					fprintf(stderr, \
						"ERROR: Failed to attempt to lock mutex when crunching bracket.\n");
				}

				/* 3f. Increment the semaphore */
				if (-1 == sem_post(update_players_semaphore)) {
					fprintf(stderr, \
						"ERROR: Failed to post semaphore when crunching bracket.\n");
				}

				/* 3g. If the this is the last process getting through the
				 * barrier, destroy the synchronization objects */
				if (is_last_process == 1) {
					if (-1 == sem_destroy(update_players_semaphore)) {
						fprintf(stderr, \
							"ERROR: Unable to destroy semaphore when crunching bracket.\n");
					}
					if (-1 == pthread_mutex_destroy(proc_finished_mutex)) {
						fprintf(stderr, \
							"ERROR: Unable to destroy mutex when crunching bracket.\n");
					}
					if (-1 == pthread_mutex_destroy(proc_at_or_past_barrier_mutex)) {
						fprintf(stderr, \
							"ERROR: Unable to destroy mutex when crunching bracket.\n");
					}
				}

				/* 3h. For this process, munmap() the memory used for sharing
				 * the synchronization objects between processes */
				if (-1 == munmap(update_players_semaphore, sizeof(sem_t))) {
					fprintf(stderr, \
						"ERROR: Unable to munmap() semaphore when crunching bracket.\n");
				}
				if (-1 == munmap(proc_finished_mutex, sizeof(pthread_mutex_t))) {
					fprintf(stderr, \
						"ERROR: Unable to munmap() mutex when crunching bracket.\n");
				}
				if (-1 == munmap(proc_at_or_past_barrier_mutex, sizeof(pthread_mutex_t))) {
					fprintf(stderr, \
						"ERROR: Unable to munmap() mutex when crunching bracket.\n");
				}
				if (-1 == munmap(proc_finished, sizeof(char))) {
					fprintf(stderr, \
						"ERROR: Unable to munmap() synchronization variable when crunching bracket.\n");
				}
				if (-1 == munmap(proc_at_or_past_barrier, sizeof(char))) {
					fprintf(stderr, \
						"ERROR: Unable to munmap() synchronization variable when crunching bracket.\n");
				}

				/* 4. At this point, this process has past the barrier and can
				 * do its post-barrier work! */

				exit(0);
			/* If parent process, decrement semaphore before doing
			 * parent-process work */
			} else {
				/* 1. Do the parent process' work. The parent process
				 * does a lot of work after this, so the next synchronization
				 * step is far down this function. */
			}
		} else {
			adjust_absent_players_no_file(day, month, year, \
				Et.tournament_id, t_name, available_cores);
		}
	}
#endif

	for (int j = 0; j < num_outcomes; j++) {
		/* Read data from one line of bracket file into all the variables */
#ifdef __linux__
		sscanf(&outcomes[j * (MAX_FILE_PATH_LEN + 1)], \
			"%s %s %hhd %hhd %hhd %hhd %hd", \
			p1_name, p2_name, &p1_gc, &p2_gc, &day, &month, &year);
#elif _WIN32

		char *token = \
			strtok(&outcomes[j * (MAX_FILE_PATH_LEN + 1)], " ");
		int temp;

		if (token == NULL) fprintf(stderr, \
			"Not enough arguments given in bracket file\n");
		strncpy(p1_name, token, MAX_NAME_LEN);

		token = strtok(NULL, " ");
		if (token == NULL) fprintf(stderr, \
			"Not enough arguments given in bracket file\n");
		strncpy(p2_name, token, MAX_NAME_LEN);

		token = strtok(NULL, " ");
		if (token == NULL) fprintf(stderr, \
			"Not enough arguments given in bracket file\n");
		sscanf(token, "%d", &temp);
		p1_gc = (char)temp;

		token = strtok(NULL, " ");
		if (token == NULL) fprintf(stderr, \
			"Not enough arguments given in bracket file\n");
		sscanf(token, "%d", &temp);
		p2_gc = (char)temp;

		token = strtok(NULL, " ");
		if (token == NULL) fprintf(stderr, \
			"Not enough arguments given in bracket file\n");
		sscanf(token, "%d", &temp);
		day = (char)temp;

		token = strtok(NULL, " ");
		if (token == NULL) fprintf(stderr, \
			"Not enough arguments given in bracket file\n");
		sscanf(token, "%d", &temp);
		month = (char)temp;

		token = strtok(NULL, " ");
		if (token == NULL) fprintf(stderr, \
			"Not enough arguments given in bracket file\n");
		sscanf(token, "%d", &temp);
		year = (short)temp;
#else
		sscanf(&outcomes[j * (MAX_FILE_PATH_LEN + 1)], \
			"%s %s %hhd %hhd %hhd %hhd %hd", \
			p1_name, p2_name, &p1_gc, &p2_gc, &day, &month, &year);
#endif
		short p1_id;
		short p2_id;
		struct entry *p1_entry;
		struct entry *p2_entry;
		unsigned int p1_name_hash = simple_murmur_hash2(p1_name);
		unsigned int p2_name_hash = simple_murmur_hash2(p2_name);

		if (0 == hashtable_find(p1_name, p1_name_hash, &p1_entry) \
			&& p1_entry != NULL) {

				p1_id = p1_entry->id;
		/* If the player data is not already in memory,
		 * do more work intensive method */
		} else {
			long L = 0;
			long R = tourn_atten_len - 1;
			long m;
			while (L <= R) {
				m = floor(((double) (L + R)) / 2.0);
				/* Compare array[m] with the name being searched for */
				int comp = strncmp(&tourn_atten[m].name[0], p1_name, MAX_NAME_LEN);
				if (0 > comp) {
					L = m + 1;
				} else if (0 < comp) {
					R = m - 1;
				} else {
					p1_id = tourn_atten[m].id;
					R = L - 1; /* Terminate loop */
				}
			}
		}

		if (0 == hashtable_find(p2_name, p2_name_hash, &p2_entry) \
			&& p2_entry != NULL) {

				p2_id = p2_entry->id;
		/* If the player data is not already in memory,
		 * do more work intensive method */
		} else {
			long L = 0;
			long R = tourn_atten_len - 1;
			long m;
			while (L <= R) {
				m = floor(((double) (L + R)) / 2.0);
				/* Compare array[m] with the name being searched for */
				int comp = strncmp(&tourn_atten[m].name[0], p2_name, MAX_NAME_LEN);
				if (0 > comp) {
					L = m + 1;
				} else if (0 < comp) {
					R = m - 1;
				} else {
					p2_id = tourn_atten[m].id;
					R = L - 1; /* Terminate loop */
				}
			}
		}

		struct player p1;
		struct player p2;
		char p1_out;
		char p2_out;
		if (use_games == 1) {
			p1_out = 1;
			p2_out = 0;
			for (int i = 0; i < p1_gc; i++) {
				update_player_on_outcome(p1_id, p1_name, p2_id, p2_name, \
					&p1, &p2, &p1_out, &p2_out, day, month, year, \
					Et.tournament_id, t_name, season_id);
				update_player_on_outcome(p2_id, p2_name, p1_id, p1_name, \
					&p2, &p1, &p2_out, &p1_out, day, month, year, \
					Et.tournament_id, t_name, season_id);
			}
			p1_out = 0;
			p2_out = 1;
			for (int i = 0; i < p2_gc; i++) {
				update_player_on_outcome(p1_id, p1_name, p2_id, p2_name, \
					&p1, &p2, &p1_out, &p2_out, day, month, year, \
					Et.tournament_id, t_name, season_id);
				update_player_on_outcome(p2_id, p2_name, p1_id, p1_name, \
					&p2, &p1, &p2_out, &p1_out, day, month, year, \
					Et.tournament_id, t_name, season_id);
			}
		} else {
			update_player_on_outcome(p1_id, p1_name, p2_id, p2_name, \
				&p1, &p2, &p1_gc, &p2_gc, day, month, year, \
				Et.tournament_id, t_name, season_id);
			update_player_on_outcome(p2_id, p2_name, p1_id, p1_name, \
				&p2, &p1, &p2_gc, &p1_gc, day, month, year, \
				Et.tournament_id, t_name, season_id);
		}
	}

#ifdef _WIN32
#else
	if (available_cores > 1) {
		/* At this point the work of the parent process is done */

		/* 2a. Lock the proc_finished mutex */
		if (0 != pthread_mutex_lock(proc_finished_mutex)) {
			fprintf(stderr, \
				"ERROR: Failed to attempt to lock mutex when crunching bracket.\n");
		}

		/* 2b. Increment the proc_finished variable. */
		(*proc_finished)++;

		/* 2c. Store in a variable whether or not the barrier count has
		 * been reached */
		char is_last_process = ((*proc_finished) == barrier_count);

		/* 2d. Unlock the proc_finished mutex */
		if (0 != pthread_mutex_unlock(proc_finished_mutex)) {
			fprintf(stderr, \
				"ERROR: Failed to attempt to lock mutex when crunching bracket.\n");
		}

		/* 2e. If the barrier count has been reached, increment the
		 * semaphore */
		if (is_last_process == 1) {
			if (-1 == sem_post(update_players_semaphore)) {
				fprintf(stderr, \
					"ERROR: Failed to post semaphore when crunching bracket.\n");
			}
		}

		/* 3a. Wait for the proc_at_or_past_barrier mutex. */
		if (0 != pthread_mutex_lock(proc_at_or_past_barrier_mutex)) {
			fprintf(stderr, \
				"ERROR: Failed to attempt to lock mutex when crunching bracket.\n");
		}

		/* 3b. Increment the proc_at_or_past_barrier variable. */
		(*proc_at_or_past_barrier)++;

		/* 3c. Store in a variable whether or not the barrier count has
		 * been reached */
		is_last_process = ((*proc_at_or_past_barrier) == barrier_count);

		/* 3d. Decrement the semaphore */
		if (-1 == sem_wait(update_players_semaphore)) {
			fprintf(stderr, \
				"ERROR: Failed to wait for semaphore when crunching bracket.\n");
		}

		/* 3e. Unlock the proc_at_or_past_barrier mutex. */
		if (0 != pthread_mutex_unlock(proc_at_or_past_barrier_mutex)) {
			fprintf(stderr, \
				"ERROR: Failed to attempt to lock mutex when crunching bracket.\n");
		}

		/* 3f. Increment the semaphore */
		if (-1 == sem_post(update_players_semaphore)) {
			fprintf(stderr, \
				"ERROR: Failed to post semaphore when crunching bracket.\n");
		}

		/* 3g. If the this is the last process getting through the
		 * barrier, destroy the synchronization objects */
		if (is_last_process == 1) {
			if (-1 == sem_destroy(update_players_semaphore)) {
				fprintf(stderr, \
					"ERROR: Unable to destroy semaphore when crunching bracket.\n");
			}
			if (-1 == pthread_mutex_destroy(proc_finished_mutex)) {
				fprintf(stderr, \
					"ERROR: Unable to destroy mutex when crunching bracket.\n");
			}
			if (-1 == pthread_mutex_destroy(proc_at_or_past_barrier_mutex)) {
				fprintf(stderr, \
					"ERROR: Unable to destroy mutex when crunching bracket.\n");
			}
		}

		/* 3h. For this process, munmap() the memory used for sharing
		 * the synchronization objects between processes */
		if (-1 == munmap(update_players_semaphore, sizeof(sem_t))) {
			fprintf(stderr, \
				"ERROR: Unable to munmap() semaphore when crunching bracket.\n");
		}
		if (-1 == munmap(proc_finished_mutex, sizeof(pthread_mutex_t))) {
			fprintf(stderr, \
				"ERROR: Unable to munmap() mutex when crunching bracket.\n");
		}
		if (-1 == munmap(proc_at_or_past_barrier_mutex, sizeof(pthread_mutex_t))) {
			fprintf(stderr, \
				"ERROR: Unable to munmap() mutex when crunching bracket.\n");
		}
		if (-1 == munmap(proc_finished, sizeof(char))) {
			fprintf(stderr, \
				"ERROR: Unable to munmap() synchronization variable when crunching bracket.\n");
		}
		if (-1 == munmap(proc_at_or_past_barrier, sizeof(char))) {
			fprintf(stderr, \
				"ERROR: Unable to munmap() synchronization variable when crunching bracket.\n");
		}

		/* 4. At this point, this process has past the barrier and can
		 * do its post-barrier work! */
	}
#endif

	return 0;
}


/* Takes a file path to a bracket file, and runs the bracket.
 *
 * \param '*bracket_file_path' a file path to a bracket file.
 * \return an int representing if the function succeeded or failed.
 *     Negative on failure. 0 upon success.
 */
int run_single_bracket(char *bracket_file_path) {
	/* If the silent flags haven't been set, print progress */
	if (silent == 0 && silent_all == 0) {
		if (use_games == 1) {
			fprintf(stdout, "running \"%s\" using games ...", bracket_file_path);
			fflush(stdout);
		} else {
			fprintf(stdout, "running \"%s\" ...", bracket_file_path);
			fflush(stdout);
		}
	}

	short latest_season_id = s_file_get_latest_season_id(data_dir);
	/* If the system has not seen any activity yet, update season id from
	 * uninitialized -1 to safe 0 */
	if (latest_season_id == -1) {
		s_file_set_latest_season_id(data_dir, latest_season_id + 1);
		latest_season_id = 0;
	}
	int ret = update_players(bracket_file_path, latest_season_id);

	if (silent == 0 && silent_all == 0) {
		if (ret == 0) {
			fprintf(stdout, "DONE\n");
			return 0;
		} else {
			fprintf(stdout, "ERROR\n");
			return 0;
		}
	}

	/* small silent only affects the first following input flag. Turn off */
	if (silent == 1) silent = 0;
	return 0;
}


/* Takes a file path to a bracket list file. For each line in the file,
 * attempts to access a file of the name [line_in_bracket_list_file_path_file]
 * and run the bracket.
 *
 * \param '*bracket_list_file_path' a file path to a bracket list file
 * \return an int representing if the function succeeded or failed.
 *     Negative on failure. 0 upon success.
 */
int run_brackets(char *bracket_list_file_path) {
	FILE *bracket_list_file = fopen(bracket_list_file_path, "r");
	if (bracket_list_file == NULL) {
		perror("fopen (run_brackets)");
		return -1;
	}

	short latest_season_id = s_file_get_latest_season_id(data_dir);
	char line[MAX_FILE_PATH_LEN + 2]; /* + 1 for \n and +1 for \0 */
	int bracket_paths_size = SIZE_BRACKET_PATHS;
	char *bracket_paths = \
		(char *)malloc((MAX_FILE_PATH_LEN + 1) * bracket_paths_size);

	int num_brk = 0;
	while (fgets(line, sizeof(line), bracket_list_file)) {
		/* Remove comments from text */
		char parse_line = 0;
		unsigned long i = 0;
		unsigned long comment_symbol_len = strlen(COMMENT_SYMBOL);

		if (comment_symbol_len > 0) {
			while (i <= strlen(line) - comment_symbol_len) {
				/* If it reaches a character that matches the first character
				 * of the comment symbol */
				if (line[i] == COMMENT_SYMBOL[0]) {
					/* If there is a comment, do not parse the line */
					if (strncmp( \
						&line[i], COMMENT_SYMBOL, comment_symbol_len) == 0) {

						line[i] = '\0';
						break;
					}
				}
				i++;
			}
			i = 0;
		}

		/* Check if the line is non-empty */
		while (i < strlen(line)) {
			/* If it reaches a non-whitespace character */
			if (line[i] != '	' && line[i] != ' ' \
				&& line[i] != '\n' && line[i] != '\r') {

				parse_line = 1;
				break;
			}
			i++;
		}
		if (parse_line == 1) {
			/* Code to catch all several forms of newline such as:
			 * '\n', "\r\n", '\r', "\n\m". Actually catches "[\n\r].*"
			 * If the search for a newline didn't fail, the line ended in a
			 * newline which must be replaced */
			char *end_of_line = strchr(line, '\n');
			if (end_of_line != NULL) {
				*end_of_line = '\0';
			} else {
				end_of_line = strchr(line, '\r');
				if (end_of_line != NULL) {
					*end_of_line = '\0';
				}
			}

			/* If there is no space to add this bracket path, reallocate */
			if (num_brk + 1 > bracket_paths_size) {
				bracket_paths_size += REALLOC_BRACKET_PATHS_INC;
				bracket_paths = (char *) realloc(bracket_paths, \
					(MAX_FILE_PATH_LEN + 1) * bracket_paths_size);
				if (bracket_paths == NULL) {
					perror("realloc (generate_ratings_file)");
					return -2;
				}
			}
			strncpy(&bracket_paths[num_brk * (MAX_FILE_PATH_LEN + 1)], \
				&line[0], MAX_FILE_PATH_LEN);
			num_brk++;
		}
	}

	for (int j = 0; j < num_brk; j++) {
		/* If the silent flags haven't been set, print progress */
		if (silent == 0 && silent_all == 0) {
			if (use_games == 1) {
				fprintf(stdout, "running \"%s\" using games ...", \
					&bracket_paths[j * (MAX_FILE_PATH_LEN + 1)]);
				fflush(stdout);
			} else {
				fprintf(stdout, "running \"%s\" ...", \
					&bracket_paths[j * (MAX_FILE_PATH_LEN + 1)]);
				fflush(stdout);
			}
		}
		update_players(&bracket_paths[j * (MAX_FILE_PATH_LEN + 1)], \
			latest_season_id + 1);
		s_file_set_latest_season_id(data_dir, latest_season_id + 1);

		if (silent == 0 && silent_all == 0) fprintf(stdout, "DONE\n");
		/* small silent only affects the first following input flag.
		 * Turn off */
		if (silent == 1) silent = 0;
	}

	fclose(bracket_list_file);
	return 0;
}


/** Creates a file listing all the players' glicko details at the location
 * 'output_file_path'.
 *
 * \param '*file_path' the file path for a file containing, on each line,
 *     the file path of a player file generated by this program.
 * \param '*output_file_path' the file path at which to create the pr
 *     file.
 * \return int representing if the function failed or succeeded. 0 upon
 *     success, < 0 upon failure.
 */
// TODO: Combine with generate_ratings_file_full once it has been divided
int generate_ratings_file(char* filter_file_path, char* output_file_path) {
	FILE *players = fopen(filter_file_path, "r");
	if (players == NULL) {
		perror("fopen (generate_ratings_file)");
		return -1;
	}

	if (flag_output_to_stdout == 0) {
		clear_file(output_file_path);
	}

	/* Player list file is a series of names followed by newlines '\n'
	 * therefore the longest line that should be supported should be the
	 * longest name */
	char line[MAX_NAME_LEN];
	int pr_entries_num = 0;
	int longest_name_length = 0;
	int longest_attended = 0;
	int longest_outcomes = 0;
	/* Create a starting point pr entry array */
	int pr_entries_size = SIZE_PR_ENTRY;
	struct entry *players_pr_entries = \
		(struct entry *)malloc(sizeof(struct entry) * pr_entries_size);
	struct entry temp;

	while (fgets(line, sizeof(line), players)) {
		/* Replace newline with null terminator */
		char *end_of_line = strchr(line, '\n');
		if (end_of_line == NULL) {
			perror("strchr (generate_ratings_file)");
			return -2;
		}
		*end_of_line = '\0';
		char *full_player_path = \
			player_dir_file_path_with_player_dir(player_dir, line);
		/* If player in filter file does NOT have a player file */
#ifdef __linux__
		if (access(full_player_path, R_OK | W_OK) == -1) {
#elif _WIN32
		if (access(full_player_path, R_OK | W_OK) == -1) {
#else
		if (access(full_player_path, R_OK | W_OK) == -1) {
#endif
			continue;
		}

		/* If the player file was able to be read properly... */
		if (0 == p_file_read_last_entry(data_dir, full_player_path, &temp)) {
			// TODO: something here
			int num_events = \
				p_file_get_events_attended_count(full_player_path);

			if (longest_attended < num_events) longest_attended = num_events;
			int num_outcomes = p_file_get_outcome_count(full_player_path);

			if (longest_outcomes < num_outcomes) {
				longest_outcomes = num_outcomes;
			}
			// If the player attended the minimum number of events
			if (num_events >= pr_minimum_events) {
				/* If there is no space to add this pr entry, reallocate */
				if (pr_entries_num + 1 > pr_entries_size) {
					pr_entries_size += REALLOC_PR_ENTRIES_INC;
					players_pr_entries = (struct entry *) \
						realloc(players_pr_entries, \
						sizeof(struct entry) * pr_entries_size);
					if (players_pr_entries == NULL) {
						perror("realloc (generate_ratings_file)");
						return -2;
					}
				}
				/* ...add the player data to the player pr entry array*/
				players_pr_entries[pr_entries_num] = temp;
				pr_entries_num++;
			}
		}
		free(full_player_path);
	}

	/* Sort entries in the list by rating into non-increasing order */
	merge_sort_pr_entry_array(players_pr_entries, pr_entries_num);
	/* Get the longest name on the pr */
	for (int i = 0; i < pr_entries_num; i++) {
		if (longest_name_length < players_pr_entries[i].len_name) {
			longest_name_length = players_pr_entries[i].len_name;
		}
	}
	/* Store how long in characters the longest_attended count would take
	 * in longest_attended */
	char string_rep[128];
	sprintf(string_rep, "%d", longest_attended);
	longest_attended = strlen(string_rep);
	/* Store how long in characters the longest_attended count would take
	 * in longest_attended */
	sprintf(string_rep, "%d", longest_outcomes);
	longest_outcomes = strlen(string_rep);
	/* Append each entry pr file */
	for (int i = 0; i < pr_entries_num; i++) {
		if (verbose == 1) {
			append_pr_entry_to_file_verbose( \
				player_dir, \
				&players_pr_entries[i], \
				output_file_path, \
				longest_name_length, \
				longest_attended, \
				longest_outcomes,
				(bool) flag_output_to_stdout);
		} else {
			append_pr_entry_to_file( \
				player_dir, \
				&players_pr_entries[i], \
				output_file_path, \
				longest_name_length, \
				(bool) flag_output_to_stdout);
		}
	}

	fclose(players);
	return 0;
}


/* Takes a file path, clears the contents of the file and writes
 * player rating data for every player in the player directory
 * 'player_dir', one line per player, for all players who pass
 * any applicable filters.
 *
 * \param '*output_file_path' the file path to create the
 *     ratings file at.
 * \return an int representing if the function succeeded or failed.
 *     Negative on failure, 0 upon success.
 */
// TODO: holy moly divide this function into its parts. One for
//       making the list of struct records, one for printing at least.
int generate_ratings_file_full(char *output_file_path) {
	DIR *p_dir;
	struct dirent *entry;
	if ((p_dir = opendir(player_dir)) != NULL) {
		if (flag_output_to_stdout == 0) {
			clear_file(output_file_path);
		}

		/* Player list file is a series of names followed by newlines '\n'
		 * therefore the longest line that should be supported should be the
		 * longest name */
		int pr_entries_num = 0;
		int longest_name_length = 0;
		int longest_attended = 0;
		int longest_outcomes = 0;
		/* Create a starting point pr entry array */
		int pr_entries_size = SIZE_PR_ENTRY;
		struct entry *players_pr_entries = \
			(struct entry *)malloc(sizeof(struct entry) * pr_entries_size);
		struct entry temp;

		while ((entry = readdir(p_dir)) != NULL) {
			// Make sure it doesn't count directories
			char *path_to_entry = extend_path(player_dir, entry->d_name);
			if (1 == is_dir(path_to_entry)) {
				char *full_player_path = \
					player_dir_file_path_with_player_dir(player_dir, entry->d_name);
				/* If the player file was able to be read properly... */
				if (0 == p_file_read_last_entry(data_dir, full_player_path, &temp)) {
					// TODO: finish this, if the m flag isn't used, no need to
					// do all this
					//if (pr_minimum_events > 0) {
					int num_events = \
						p_file_get_events_attended_count(full_player_path);

					if (longest_attended < num_events) {
						longest_attended = num_events;
					}

					int num_outcomes = \
						p_file_get_outcome_count(full_player_path);

					if (longest_outcomes < num_outcomes) {
						longest_outcomes = num_outcomes;
					}
					// If the player attended the minimum number of events
					if (num_events >= pr_minimum_events) {
						/* If there is no space to add this pr entry,
						 * reallocate */
						if (pr_entries_num + 1 > pr_entries_size) {
							pr_entries_size += REALLOC_PR_ENTRIES_INC;
							players_pr_entries = (struct entry *) \
								realloc(players_pr_entries, \
								sizeof(struct entry) * pr_entries_size);
							if (players_pr_entries == NULL) {
								perror("realloc (generate_ratings_file)");
								return -2;
							}
						}
						/* ...add the player data to the player
						 * pr entry array */
						players_pr_entries[pr_entries_num] = temp;
						pr_entries_num++;
					}
				} else {
					return -3;
				}
				free(full_player_path);
			}
			free(path_to_entry);
		}
		closedir(p_dir);
		/* Sort entries in the list by rating into non-increasing order */
		merge_sort_pr_entry_array(players_pr_entries, pr_entries_num);
		/* Get the longest name on the pr */
		for (int i = 0; i < pr_entries_num; i++) {
			if (longest_name_length < players_pr_entries[i].len_name) {
				longest_name_length = players_pr_entries[i].len_name;
			}
		}
		/* Store how long in characters the longest_attended count would take
		 * in longest_attended */
		char string_rep[128];
		sprintf(string_rep, "%d", longest_attended);
		longest_attended = strlen(string_rep);
		/* Store how long in characters the longest_attended count would take
		 * in longest_attended */
		sprintf(string_rep, "%d", longest_outcomes);
		longest_outcomes = strlen(string_rep);
		/* Append each entry pr file */
		for (int i = 0; i < pr_entries_num; i++) {
			if (verbose == 1) {
				append_pr_entry_to_file_verbose( \
					player_dir,
					&players_pr_entries[i], \
					output_file_path, \
					longest_name_length, \
					longest_attended, \
					longest_outcomes, \
					(bool) flag_output_to_stdout);
			} else {
				append_pr_entry_to_file( \
					player_dir,
					&players_pr_entries[i], \
					output_file_path, \
					longest_name_length, \
					(bool) flag_output_to_stdout);
			}
		}
		return 0;
	} else {
		perror("opendir (generate_ratings_file_full)");
		return -1;
	}
}


/* Takes 2 player names and a struct record, modifies the given struct record
 * to be the first players record/head-to-head/matchup on the second player.
 *
 * \param '*player1' the name of the first player.
 * \param '*player2' the name of the second player.
 * \param '*ret' A struct record, which upon the successful completion of this
 *     function, will contain the first player's record against
 *     the second player.
 * \return an int representing if this function succeeded or failed.
 *     Negative upon failure, 0 upon success.
 */
int get_record(char *player1, char *player2, struct record *ret) {

	char *full_player1_path = \
		player_dir_file_path_with_player_dir(player_dir, player1);
	/* Read the starter data in the file */
	struct entry ent;
	p_file_read_start_from_file(full_player1_path, &ent);

	FILE *p_file = fopen(full_player1_path, "rb");
	if (p_file == NULL) {
		fprintf(stderr, "Error: get_record: opening file \"%s\": ", \
			full_player1_path);
		perror("");
		return -1;
	}
	strncpy(ret->name, ent.name, MAX_NAME_LEN);
	strncpy(ent.opp_name, player2, MAX_NAME_LEN);
	// TODO: actually get player2 name from their file.
	// '*player2' is just a file name
	strncpy(ret->opp_name, player2, MAX_NAME_LEN);
	init_record(ret);

	int num_ent = \
		p_file_get_number_of_outcomes_against(data_dir, full_player1_path, \
			player2);
	int cur_opp_ent_num = 0;
	unsigned long num_of_last_outcomes = sizeof(ret->last_outcomes) - 1;

	/* If there was an error with this function */
	if (opp_file_get_id_from_name(data_dir, &ent) < 0) return -3;

	/* Get to the entries in the player file */
	if (0 != fseek(p_file, 0, SEEK_SET)) return -4;
	int t;
	if (0 != (t = p_file_open_position_at_start_of_entries(p_file))) {
		fprintf(stderr, \
			"Error: get_record: (%d) (p_file_open_position_at_start_of_entries(%s)): ", \
			t, full_player1_path);
		perror("");
		return -2;
	}

	while (p_file_open_read_next_opp_entry( \
		data_dir, p_file, &ent, ent.opp_id) == 0) {

		/* If the opponent for the given entry is the player of interest */
		if (0 == strncmp(ent.opp_name, player2, MAX_NAME_LEN)) {
			if (ent.gc > ent.opp_gc) ret->wins += 1;
			else if (ent.gc == ent.opp_gc) ret->ties += 1;
			else if (ent.gc < ent.opp_gc) ret->losses += 1;
			/* If the current entry is one of the last x many,
			 * add it to the recent outcome list */
			if ((unsigned long)(num_ent - cur_opp_ent_num)
				< num_of_last_outcomes) {

				if (ent.gc > ent.opp_gc) {
					ret->last_outcomes[cur_opp_ent_num] = 'W';
				} else if (ent.gc == ent.opp_gc) {
					ret->last_outcomes[cur_opp_ent_num] = 'T';
				/* Assert: (ent.gc < ent.opp_gc) */
				} else {
					ret->last_outcomes[cur_opp_ent_num] = 'L';
				}
			}
			cur_opp_ent_num++;
		}
	}
	ret->last_outcomes[cur_opp_ent_num] = '\0';
	free(full_player1_path);
	fclose(p_file);

	return 0;
}


/* Takes a path to a player file and a pointer to an int.
 * Reads the player file, creates an array of struct records, one
 * for every player player1 has ever played, containing player1's wins, ties,
 * losses, etc. And returns a pointer to said array. Modifies '*num_of_records'
 * to contain the number of elements in that array.
 *
 * \param '*file_path' A file path to an player-file.
 * \param '*num_of_records' An int pointer that will be moified to contain
 *     the number of records in the returned array.
 * \return a pointer to a 'struct record' that is an array of 'struct record's
 *     indexed by 'opp_id'. Returns NULL on failure.
 */
struct record *get_all_records(char *file_path, long *num_of_records) {

	short *opp_id_list = NULL;
	short **p_opp_id_list = &opp_id_list;
	*num_of_records = p_file_number_of_opponents(data_dir, file_path, p_opp_id_list);
	struct record *ret = \
		(struct record *)malloc(sizeof(struct record) * *num_of_records);
	/* Read the starter data in the file */
	struct entry ent;
	p_file_read_start_from_file(file_path, &ent);

	FILE *p_file = fopen(file_path, "rb");
	if (p_file == NULL) {
		perror("fopen (get_all_records)");
		return NULL;
	}

	for (int i = 0; i < *num_of_records; i++) {
		strncpy(ret[i].name, ent.name, MAX_NAME_LEN);
		init_record(&ret[i]);
	}

	/* Get number of entries for every opponent */
	// CONSIDER: only do if verbose? (Only used if verbose)
	long *num_outcome_all = \
		p_file_get_all_number_of_outcomes_against(data_dir, file_path, \
			*num_of_records, opp_id_list);
	/* Array containing the current number of entries for a given opponent */
	int *cur_opp_num_of_ent = (int *) calloc(*num_of_records, sizeof(int));

	/* Get to the entries in the player file */
	int r = p_file_open_position_at_start_of_entries(p_file);
	if (r != 0) {
		perror("get_all_records (p_file_open_position_at_start_of_entries)");
		free(num_outcome_all);
		free(cur_opp_num_of_ent);
		return NULL;
	}

	short prev_entrys_season = 0;
	while (p_file_open_read_entry(data_dir, p_file, &ent) == 0) {
		int j = 0;
		/* Find position (j) of opp_id being searched for */
		for (j = 0; j < *num_of_records; j++) {
			if (ent.opp_id == opp_id_list[j]) {
				break;
			}
		}
		// CONSIDER: OPT: replace this triple check every entry with a function
		//            that sets names once.
		/* if this is the first time updating the player's record */
		if (ret[j].wins == 0 \
			&& ret[j].ties == 0 \
			&& ret[j].losses == 0) {

			// TODO: actually get player2 name from their file.
			// '*player2' is just a file name
			strncpy(ret[j].opp_name, ent.opp_name, MAX_NAME_LEN);
		}

		/* Only update if the player has sets against this opponent */
		if (num_outcome_all[j] > 0) {
			/* If the entry is a non-competitor (RD-adjustment), ignore */
			if (ent.is_competitor == 0) continue;
			if (ent.gc > ent.opp_gc) ret[j].wins += 1;
			else if (ent.gc == ent.opp_gc) ret[j].ties += 1;
			else if (ent.gc < ent.opp_gc) ret[j].losses += 1;

			/* If the season changed, add season markers to output strings */
			if (ent.season_id != prev_entrys_season) {
				for (int i = 0; i < *num_of_records; i++) {
					/* realloc if necessary. +2 to leave space for
					 * the null term. */
					if (cur_opp_num_of_ent[i] + 2 > ret[i].num_outcomes) {
						ret[i].num_outcomes *= 2;
						ret[i].last_outcomes = \
							(char *)realloc(ret[i].last_outcomes, \
								sizeof(char) * ret[i].num_outcomes);

						if (ret[i].last_outcomes == NULL) {
							perror("realloc (get_all_records)");
							return NULL;
						}
					}
					ret[i].last_outcomes[cur_opp_num_of_ent[i]] = '|';
					cur_opp_num_of_ent[i]++;
				}
				prev_entrys_season = ent.season_id;
			}
			/* realloc if necessary. +2 to leave space for null term. */
			if (cur_opp_num_of_ent[j] + 2 > ret[j].num_outcomes) {
				ret[j].num_outcomes *= 2;
				ret[j].last_outcomes = (char *) realloc(ret[j].last_outcomes, \
					sizeof(char) * ret[j].num_outcomes);
				if (ret[j].last_outcomes == NULL) {
					perror("realloc (get_all_records)");
					return NULL;
				}
			}
			if (ent.gc > ent.opp_gc) {
				ret[j].last_outcomes[cur_opp_num_of_ent[j]] = 'W';
			} else if (ent.gc == ent.opp_gc) {
				ret[j].last_outcomes[cur_opp_num_of_ent[j]] = 'T';
			/* Assert: (ent.gc < ent.opp_gc) */
			} else {
				ret[j].last_outcomes[cur_opp_num_of_ent[j]] = 'L';
			}
			cur_opp_num_of_ent[j]++;
		}
	}
	for (int i = 0; i < *num_of_records; i++) {
		ret[i].last_outcomes[cur_opp_num_of_ent[i]] = '\0';
	}
	free(opp_id_list);
	free(num_outcome_all);
	free(cur_opp_num_of_ent);
	fclose(p_file);

	return ret;
}


/* Takes an array of player names, and the length of the array.
 * Returns the maximum 'strlen' result of an element in the array.
 *
 * \param '*players' pointer to an array of
 *     'MAX_NAME_LEN + 1' * '*(num_players)' * chars.
 * \param 'array_len' the length of the '*players' array.
 * \return an integer representing the longest name in the array.
 *     The longest possible return value is 'MAX_NAME_LEN'.
 */
long longest_name(char *players, int array_len) {
	long ret = 0;
	for (int i = 0; i < array_len; i++) {
		if (strlen(&players[(MAX_NAME_LEN + 1) * i]) > ret) {
			ret = strlen(&players[(MAX_NAME_LEN + 1)* i]);
		}
	}

	return ret;
}


/* Takes an array of player names created with a malloc or calloc call,
 * the length of the array, and a file path. Modifies the array
 * to contain only player names that exist as lines in the file.
 * changes '*num_players' accordingly.
 *
 * \param '*players' pointer to an array of
 *     'MAX_NAME_LEN + 1' * '*(num_players)' chars.
 * \param '*num_players' the length of the '*players' array.
 * \param '*filter_file_path' the file path of a pr list file.
 * \return an integer representing the success or failure of
 *     this function. 0 means sucess, negative numbers mean failure.
 */
int filter_player_list(char **players_pointer, short *num_players, \
	char *filter_file_path) {

	FILE *filter_file = fopen(filter_file_path, "r");
	if (filter_file == NULL) {
		perror("fopen (filter_player_list)");
		return -1;
	}

	int app_ind = 0;
	char line[MAX_NAME_LEN + 1];
	char *players = *(players_pointer);
	char *filtered_players = \
		(char *)malloc(sizeof(char) * (MAX_NAME_LEN + 1) * (*num_players));

	while (fgets(line, sizeof(line), filter_file)) {
		/* Replace newline with null terminator */
		char *end_of_line = strchr(line, '\n');
		if (end_of_line == NULL) {
			perror("strchr (filter_player_list)");
			return -2;
		}
		*end_of_line = '\0';

		for (int i = 0; i < *num_players; i++) {
			/* If the player name exists in the player list, add
			 * it to the filtered list of players */
			if (0 == strcmp(line, &players[(MAX_NAME_LEN + 1) * i])) {
				strncpy(&filtered_players[(MAX_NAME_LEN + 1) * app_ind], \
					line, MAX_NAME_LEN);
				app_ind++;
			}
		}
	}

	fclose(filter_file);
	free(players);
	*num_players = app_ind;
	*players_pointer = filtered_players;

	return 0;
}


/* Takes an array of player names created with a malloc or calloc call,
 * the length of the array, and a file path. Modifies the array
 * to contain only player names that have attended 'pr_minimum_events', and
 * changes '*num_players' accordingly.
 *
 * \param '*players' pointer to an array of
 *     'MAX_NAME_LEN + 1' * '*(num_players)' chars.
 * \param '*num_players' the length of the '*players' array.
 * \return an integer representing the success or failure of
 *     this function. 0 means sucess, negative numbers mean failure.
 */
int filter_player_list_min_events(char **players_pointer, short *num_players) {

	int app_ind = 0;
	char *players = *(players_pointer);
	char *filtered_players = \
		(char *)malloc(sizeof(char) * (MAX_NAME_LEN + 1) * (*num_players));

	if (filtered_players == NULL) {
		fprintf(stderr, "Error: could not malloc a new player array " \
			"(filter_player_list_min_events)");
		return -1;
	}

	for (int i = 0; i < *num_players; i++) {
		char *full_player_path = \
			player_dir_file_path_with_player_dir(player_dir, &players[i * (MAX_NAME_LEN + 1)]);
		int num_events = p_file_get_events_attended_count(full_player_path);

		/* If the player passes the filter (has gone to enough events */
		if (num_events >= pr_minimum_events) {
			strncpy(&filtered_players[(MAX_NAME_LEN + 1) * app_ind], \
				&players[i * (MAX_NAME_LEN + 1)], \
				MAX_NAME_LEN);
			app_ind++;
		}
		free(full_player_path);
	}

	free(players);
	*num_players = app_ind;
	*players_pointer = filtered_players;

	return 0;
}


int player_and_data_dirs_check_and_create(void) {
	if (0 != player_dir_check_and_create(player_dir)) {
		return -1;
	}
	if (0 != data_dir_check_and_create(data_dir)) {
		return -2;
	}
	return 0;
}


int player_and_data_dirs_reset(void) {
	if (0 != player_dir_reset_players(player_dir)) {
		return -1;
	}
	if (0 != data_dir_reset(data_dir)) {
		return -2;
	}
	return 0;
}


int main(int argc, char **argv) {

	int opt;
	struct option opt_table[] = {
		/* Don't make RD adjustments for players absent
		 * from some tournaments */
		{ "no-adjustment",  no_argument,        NULL,  '0' },
		/* Add (or create if necessary) a player entry/player entry file
		 * from user input */
		{ "events-attended",required_argument,  NULL,  'A' },
		/* Run through a given bracket file making the necessary updates
		 * to the glicko2 scores */
		{ "bracket",        required_argument,  NULL,  'b' },
		{ "brackets",       required_argument,  NULL,  'B' },
		{ "count-outcomes", required_argument,  NULL,  'c' },
		{ "matchup-csv",    required_argument,  NULL,  'C' },
		{ "player-dir",     required_argument,  NULL,  'd' },
		{ "reset-players",  no_argument,        NULL,  'e' },
		{ "filter",         required_argument,  NULL,  'f' },
		{ "use-games",      no_argument,        NULL,  'g' },
		/* Output given player file in human readable form */
		{ "history",        required_argument,  NULL,  'h' },
		/* Don't delete the player files when running a new bracket */
		{ "keep-players",   no_argument,        NULL,  'k' },
		/* Output last entry in given player file in human readable form */
		{ "min-events",     required_argument,  NULL,  'm' },
		{ "matchup-table",  required_argument,  NULL,  'M' },
		{ "no-colour",      required_argument,  NULL,  'n' },
		{ "no-ties",        required_argument,  NULL,  'N' },
		{ "output",         required_argument,  NULL,  'o' },
		{ "stdout",         no_argument,        NULL,  'O' },
		{ "records",        required_argument,  NULL,  'R' },
		{ "silent",         no_argument,        NULL,  's' },
		{ "silent-all",     no_argument,        NULL,  'S' },
		{ "verbose",        no_argument,        NULL,  'v' },
		{ "weight",         required_argument,  NULL,  'w' },
		{ 0, 0, 0, 0 }
	};
	char opt_string[] = { "0A:b:B:c:Cd:ef:gh:km:MnNo:OR:Ssvw:" };

	/* 1.1. Initialize player_dir to the file path for the player directory */
	memset(player_dir, 0, sizeof(player_dir));
	strncpy(player_dir, DEFAULT_PLAYER_DIR, sizeof(player_dir) - 1);
	/* 1.2. Initialize data_dir to the file path for the data directory */
	memset(data_dir, 0, sizeof(data_dir));
	strncpy(data_dir, DEFAULT_DATA_DIR, sizeof(data_dir) - 1);

	// TODO: put somewhere else. Right now it resets even if G2ME is called
	//     flags that wouldn't use the hash table
	/* Reset hash table */
	hashtable_reset();

	while ((opt = getopt_long(argc, argv, opt_string, opt_table, NULL)) != -1) {
		if (opt == 'A') {
			if (0 == player_and_data_dirs_check_and_create()) {
				int count;
				char *full_player_path = \
					player_dir_file_path_with_player_dir(player_dir, optarg);
				char *attended = \
					p_file_get_events_attended(data_dir, full_player_path, \
						&count);
				print_player_attended(attended, count);
				free(full_player_path);
				free(attended);
			} else {
				fprintf(stderr, "Error: 'player_dir' either could not be " \
						"created or does not exist");
			}
		} else if (opt == 'c') {
			if (0 == player_and_data_dirs_check_and_create()) {
				char *full_player_path = \
					player_dir_file_path_with_player_dir(player_dir, optarg);

				fprintf(stdout, "%d\n", \
					p_file_get_outcome_count(full_player_path));

				free(full_player_path);
			} else fprintf(stderr, ERROR_PLAYER_DIR_DNE);
		} else if (opt == 'd') {
			memset(player_dir, 0, sizeof(player_dir));
			strncpy(player_dir, optarg, sizeof(player_dir) - 1);
		} else if (opt == 'h') {
			if (0 == player_and_data_dirs_check_and_create()) {
				char *full_player_path = \
					player_dir_file_path_with_player_dir(player_dir, optarg);

				if (access(full_player_path, R_OK | W_OK) == -1) {
					fprintf(stderr, "ERROR: the given player (\"%s\") could " \
						"not be found in working directory or the given " \
						"player directory\n", optarg);
					return -1;
				}
				if (verbose == 1) {
					print_player_file_verbose(data_dir, player_dir, \
						full_player_path, pr_minimum_events);
				} else {
					print_player_file(data_dir, player_dir, full_player_path, \
						pr_minimum_events);
				}
				free(full_player_path);
			} else fprintf(stderr, ERROR_PLAYER_DIR_DNE);
		} else if (opt == 'R') {
			if (0 == player_and_data_dirs_check_and_create()) {
				char *full_player_path = \
					player_dir_file_path_with_player_dir(player_dir, optarg);

				if (access(full_player_path, R_OK | W_OK) == -1) {
					fprintf(stderr, "ERROR: the given player (\"%s\") could " \
						"not be found in working directory or the given " \
						"player directory\n", optarg);
					return -1;
				}
				print_player_records(player_dir, full_player_path, \
					pr_minimum_events);
				free(full_player_path);
			} else fprintf(stderr, ERROR_PLAYER_DIR_DNE);
		}

		switch (opt) {
			case '0': calc_absent_players = 0; break;
			case 'b':
				if (0 == player_and_data_dirs_check_and_create()) {
					if (keep_players == 0) player_and_data_dirs_reset();
					if (keep_players == 0) {
						// TODO: put somewhere else. Would be useful to not reset, possibly
						/* Reset hash table */
						hashtable_reset();
					}
					run_single_bracket(optarg);
				} else fprintf(stderr, ERROR_PLAYER_DIR_DNE);
				break;
			case 'B':
				if (0 == player_and_data_dirs_check_and_create()) {
					if (keep_players == 0) player_and_data_dirs_reset();
					if (keep_players == 0) {
						// TODO: put somewhere else. Would be useful to not reset, possibly
						/* Reset hash table */
						hashtable_reset();
					}
					run_brackets(optarg);
				} else fprintf(stderr, ERROR_PLAYER_DIR_DNE);
				break;
			case 'C':
				if (0 == player_and_data_dirs_check_and_create()) {
					print_matchup_table_csv(data_dir, pr_minimum_events); break;
				} else fprintf(stderr, ERROR_PLAYER_DIR_DNE);
			case 'e':
				if (0 == player_and_data_dirs_check_and_create()) {
					player_and_data_dirs_reset();
				} else fprintf(stderr, ERROR_PLAYER_DIR_DNE);
				break;
			case 'f':
				f_flag_used = 1;
				strncpy(filter_file_path, optarg, \
					sizeof(filter_file_path) - 1);
				break;
			case 'g': use_games = 1; break;
			case 'k': keep_players = 1; break;
			case 'm': pr_minimum_events = atoi(optarg); break;
			case 'M': print_matchup_table(data_dir, pr_minimum_events); break;
			case 'n': colour_output = 0; break;
			case 'N': print_ties = 0; break;
			case 'o':
				if (0 == player_and_data_dirs_check_and_create()) {
					if (f_flag_used) {
						int ret = \
							generate_ratings_file(filter_file_path, optarg);
						if (ret != 0) return ret;
					} else {
						int ret = generate_ratings_file_full(optarg);
						if (ret != 0) return ret;
					}
				} else fprintf(stderr, ERROR_PLAYER_DIR_DNE);
				break;
			case 'O':
				if (0 == player_and_data_dirs_check_and_create()) {
					flag_output_to_stdout = 1;
					if (f_flag_used) {
						int ret = \
							generate_ratings_file(filter_file_path, optarg);
						if (ret != 0) return ret;
					} else {
						int ret = generate_ratings_file_full(optarg);
						if (ret != 0) return ret;
					}
				} else fprintf(stderr, ERROR_PLAYER_DIR_DNE);
				break;
			case 's': silent = 1; break;
			case 'S': silent_all = 1; break;
			case 'v': verbose = 1; break;
			case 'w': flag_outcome_weight = strtod(optarg, NULL); break;
		}
	}

	return 0;
}
